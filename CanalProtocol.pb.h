// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CanalProtocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CanalProtocol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_CanalProtocol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_CanalProtocol_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CanalProtocol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_CanalProtocol_2eproto;
namespace com {
namespace alibaba {
namespace otter {
namespace canal {
namespace protocol {
class Ack;
struct AckDefaultTypeInternal;
extern AckDefaultTypeInternal _Ack_default_instance_;
class ClientAck;
struct ClientAckDefaultTypeInternal;
extern ClientAckDefaultTypeInternal _ClientAck_default_instance_;
class ClientAuth;
struct ClientAuthDefaultTypeInternal;
extern ClientAuthDefaultTypeInternal _ClientAuth_default_instance_;
class ClientRollback;
struct ClientRollbackDefaultTypeInternal;
extern ClientRollbackDefaultTypeInternal _ClientRollback_default_instance_;
class Dump;
struct DumpDefaultTypeInternal;
extern DumpDefaultTypeInternal _Dump_default_instance_;
class Get;
struct GetDefaultTypeInternal;
extern GetDefaultTypeInternal _Get_default_instance_;
class Handshake;
struct HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class HeartBeat;
struct HeartBeatDefaultTypeInternal;
extern HeartBeatDefaultTypeInternal _HeartBeat_default_instance_;
class Messages;
struct MessagesDefaultTypeInternal;
extern MessagesDefaultTypeInternal _Messages_default_instance_;
class Packet;
struct PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class Sub;
struct SubDefaultTypeInternal;
extern SubDefaultTypeInternal _Sub_default_instance_;
class Unsub;
struct UnsubDefaultTypeInternal;
extern UnsubDefaultTypeInternal _Unsub_default_instance_;
}  // namespace protocol
}  // namespace canal
}  // namespace otter
}  // namespace alibaba
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template <>
::com::alibaba::otter::canal::protocol::Ack* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Ack>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::ClientAck* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::ClientAck>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::ClientAuth* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::ClientAuth>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::ClientRollback* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::ClientRollback>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Dump* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Dump>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Get* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Get>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Handshake* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Handshake>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::HeartBeat* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::HeartBeat>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Messages* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Messages>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Packet* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Packet>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Sub* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Sub>(Arena*);
template <>
::com::alibaba::otter::canal::protocol::Unsub* Arena::CreateMaybeMessage<::com::alibaba::otter::canal::protocol::Unsub>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace com {
namespace alibaba {
namespace otter {
namespace canal {
namespace protocol {
enum Compression : int {
  COMPRESSIONCOMPATIBLEPROTO2 = 0,
  NONE = 1,
  ZLIB = 2,
  GZIP = 3,
  LZF = 4,
  Compression_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Compression_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Compression_IsValid(int value);
constexpr Compression Compression_MIN = static_cast<Compression>(0);
constexpr Compression Compression_MAX = static_cast<Compression>(4);
constexpr int Compression_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Compression_descriptor();
template <typename T>
const std::string& Compression_Name(T value) {
  static_assert(std::is_same<T, Compression>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Compression_Name().");
  return Compression_Name(static_cast<Compression>(value));
}
template <>
inline const std::string& Compression_Name(Compression value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Compression_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Compression_Parse(absl::string_view name, Compression* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Compression>(
      Compression_descriptor(), name, value);
}
enum PacketType : int {
  PACKAGETYPECOMPATIBLEPROTO2 = 0,
  HANDSHAKE = 1,
  CLIENTAUTHENTICATION = 2,
  ACK = 3,
  SUBSCRIPTION = 4,
  UNSUBSCRIPTION = 5,
  GET = 6,
  MESSAGES = 7,
  CLIENTACK = 8,
  SHUTDOWN = 9,
  DUMP = 10,
  HEARTBEAT = 11,
  CLIENTROLLBACK = 12,
  PacketType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PacketType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PacketType_IsValid(int value);
constexpr PacketType PacketType_MIN = static_cast<PacketType>(0);
constexpr PacketType PacketType_MAX = static_cast<PacketType>(12);
constexpr int PacketType_ARRAYSIZE = 12 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PacketType_descriptor();
template <typename T>
const std::string& PacketType_Name(T value) {
  static_assert(std::is_same<T, PacketType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PacketType_Name().");
  return PacketType_Name(static_cast<PacketType>(value));
}
template <>
inline const std::string& PacketType_Name(PacketType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PacketType_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool PacketType_Parse(absl::string_view name, PacketType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PacketType>(
      PacketType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Packet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {}
  ~Packet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Packet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Packet(const Packet& from);
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Packet& default_instance() {
    return *internal_default_instance();
  }
  enum MagicNumberPresentCase {
    kMagicNumber = 1,
    MAGIC_NUMBER_PRESENT_NOT_SET = 0,
  };

  enum VersionPresentCase {
    kVersion = 2,
    VERSION_PRESENT_NOT_SET = 0,
  };

  enum CompressionPresentCase {
    kCompression = 4,
    COMPRESSION_PRESENT_NOT_SET = 0,
  };

  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(Packet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Packet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Packet& from) {
    Packet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Packet";
  }
  protected:
  explicit Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 5,
    kTypeFieldNumber = 3,
    kMagicNumberFieldNumber = 1,
    kVersionFieldNumber = 2,
    kCompressionFieldNumber = 4,
  };
  // bytes body = 5;
  void clear_body() ;
  const std::string& body() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* ptr);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .com.alibaba.otter.canal.protocol.PacketType type = 3;
  void clear_type() ;
  ::com::alibaba::otter::canal::protocol::PacketType type() const;
  void set_type(::com::alibaba::otter::canal::protocol::PacketType value);

  private:
  ::com::alibaba::otter::canal::protocol::PacketType _internal_type() const;
  void _internal_set_type(::com::alibaba::otter::canal::protocol::PacketType value);

  public:
  // int32 magic_number = 1;
  bool has_magic_number() const;
  void clear_magic_number() ;
  ::int32_t magic_number() const;
  void set_magic_number(::int32_t value);

  private:
  ::int32_t _internal_magic_number() const;
  void _internal_set_magic_number(::int32_t value);

  public:
  // int32 version = 2;
  bool has_version() const;
  void clear_version() ;
  ::int32_t version() const;
  void set_version(::int32_t value);

  private:
  ::int32_t _internal_version() const;
  void _internal_set_version(::int32_t value);

  public:
  // .com.alibaba.otter.canal.protocol.Compression compression = 4;
  bool has_compression() const;
  void clear_compression() ;
  ::com::alibaba::otter::canal::protocol::Compression compression() const;
  void set_compression(::com::alibaba::otter::canal::protocol::Compression value);

  private:
  ::com::alibaba::otter::canal::protocol::Compression _internal_compression() const;
  void _internal_set_compression(::com::alibaba::otter::canal::protocol::Compression value);

  public:
  void clear_magic_number_present();
  MagicNumberPresentCase magic_number_present_case() const;
  void clear_version_present();
  VersionPresentCase version_present_case() const;
  void clear_compression_present();
  CompressionPresentCase compression_present_case() const;
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Packet)
 private:
  class _Internal;
  void set_has_magic_number();
  void set_has_version();
  void set_has_compression();

  inline bool has_magic_number_present() const;
  inline void clear_has_magic_number_present();

  inline bool has_version_present() const;
  inline void clear_has_version_present();

  inline bool has_compression_present() const;
  inline void clear_has_compression_present();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    int type_;
    union MagicNumberPresentUnion {
      constexpr MagicNumberPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int32_t magic_number_;
    } magic_number_present_;
    union VersionPresentUnion {
      constexpr VersionPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int32_t version_;
    } version_present_;
    union CompressionPresentUnion {
      constexpr CompressionPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int compression_;
    } compression_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[3];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class HeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.HeartBeat) */ {
 public:
  inline HeartBeat() : HeartBeat(nullptr) {}
  ~HeartBeat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeat(const HeartBeat& from);
  HeartBeat(HeartBeat&& from) noexcept
    : HeartBeat() {
    *this = ::std::move(from);
  }

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeat& operator=(HeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeat* internal_default_instance() {
    return reinterpret_cast<const HeartBeat*>(
               &_HeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HeartBeat& a, HeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeat& from) {
    HeartBeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.HeartBeat";
  }
  protected:
  explicit HeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendTimestampFieldNumber = 1,
    kStartTimestampFieldNumber = 2,
  };
  // int64 send_timestamp = 1;
  void clear_send_timestamp() ;
  ::int64_t send_timestamp() const;
  void set_send_timestamp(::int64_t value);

  private:
  ::int64_t _internal_send_timestamp() const;
  void _internal_set_send_timestamp(::int64_t value);

  public:
  // int64 start_timestamp = 2;
  void clear_start_timestamp() ;
  ::int64_t start_timestamp() const;
  void set_start_timestamp(::int64_t value);

  private:
  ::int64_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.HeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t send_timestamp_;
    ::int64_t start_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Handshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Handshake) */ {
 public:
  inline Handshake() : Handshake(nullptr) {}
  ~Handshake() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Handshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Handshake(const Handshake& from);
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handshake& operator=(Handshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handshake& default_instance() {
    return *internal_default_instance();
  }
  enum CommunicationEncodingPresentCase {
    kCommunicationEncoding = 1,
    COMMUNICATION_ENCODING_PRESENT_NOT_SET = 0,
  };

  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }
  inline void Swap(Handshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handshake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Handshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Handshake& from) {
    Handshake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Handshake";
  }
  protected:
  explicit Handshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedsFieldNumber = 2,
    kSupportedCompressionsFieldNumber = 3,
    kCommunicationEncodingFieldNumber = 1,
  };
  // bytes seeds = 2;
  void clear_seeds() ;
  const std::string& seeds() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_seeds(Arg_&& arg, Args_... args);
  std::string* mutable_seeds();
  PROTOBUF_NODISCARD std::string* release_seeds();
  void set_allocated_seeds(std::string* ptr);

  private:
  const std::string& _internal_seeds() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seeds(
      const std::string& value);
  std::string* _internal_mutable_seeds();

  public:
  // .com.alibaba.otter.canal.protocol.Compression supported_compressions = 3;
  void clear_supported_compressions() ;
  ::com::alibaba::otter::canal::protocol::Compression supported_compressions() const;
  void set_supported_compressions(::com::alibaba::otter::canal::protocol::Compression value);

  private:
  ::com::alibaba::otter::canal::protocol::Compression _internal_supported_compressions() const;
  void _internal_set_supported_compressions(::com::alibaba::otter::canal::protocol::Compression value);

  public:
  // string communication_encoding = 1;
  bool has_communication_encoding() const;
  void clear_communication_encoding() ;
  const std::string& communication_encoding() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_communication_encoding(Arg_&& arg, Args_... args);
  std::string* mutable_communication_encoding();
  PROTOBUF_NODISCARD std::string* release_communication_encoding();
  void set_allocated_communication_encoding(std::string* ptr);

  private:
  const std::string& _internal_communication_encoding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_communication_encoding(
      const std::string& value);
  std::string* _internal_mutable_communication_encoding();

  public:
  void clear_communication_encoding_present();
  CommunicationEncodingPresentCase communication_encoding_present_case() const;
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Handshake)
 private:
  class _Internal;
  void set_has_communication_encoding();

  inline bool has_communication_encoding_present() const;
  inline void clear_has_communication_encoding_present();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seeds_;
    int supported_compressions_;
    union CommunicationEncodingPresentUnion {
      constexpr CommunicationEncodingPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr communication_encoding_;
    } communication_encoding_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class ClientAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.ClientAuth) */ {
 public:
  inline ClientAuth() : ClientAuth(nullptr) {}
  ~ClientAuth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientAuth(const ClientAuth& from);
  ClientAuth(ClientAuth&& from) noexcept
    : ClientAuth() {
    *this = ::std::move(from);
  }

  inline ClientAuth& operator=(const ClientAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientAuth& operator=(ClientAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientAuth& default_instance() {
    return *internal_default_instance();
  }
  enum NetReadTimeoutPresentCase {
    kNetReadTimeout = 3,
    NET_READ_TIMEOUT_PRESENT_NOT_SET = 0,
  };

  enum NetWriteTimeoutPresentCase {
    kNetWriteTimeout = 4,
    NET_WRITE_TIMEOUT_PRESENT_NOT_SET = 0,
  };

  static inline const ClientAuth* internal_default_instance() {
    return reinterpret_cast<const ClientAuth*>(
               &_ClientAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientAuth& a, ClientAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientAuth& from) {
    ClientAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.ClientAuth";
  }
  protected:
  explicit ClientAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kDestinationFieldNumber = 5,
    kClientIdFieldNumber = 6,
    kFilterFieldNumber = 7,
    kStartTimestampFieldNumber = 8,
    kNetReadTimeoutFieldNumber = 3,
    kNetWriteTimeoutFieldNumber = 4,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* ptr);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // bytes password = 2;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string destination = 5;
  void clear_destination() ;
  const std::string& destination() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // string client_id = 6;
  void clear_client_id() ;
  const std::string& client_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* ptr);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string filter = 7;
  void clear_filter() ;
  const std::string& filter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter(Arg_&& arg, Args_... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* ptr);

  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(
      const std::string& value);
  std::string* _internal_mutable_filter();

  public:
  // int64 start_timestamp = 8;
  void clear_start_timestamp() ;
  ::int64_t start_timestamp() const;
  void set_start_timestamp(::int64_t value);

  private:
  ::int64_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(::int64_t value);

  public:
  // int32 net_read_timeout = 3;
  bool has_net_read_timeout() const;
  void clear_net_read_timeout() ;
  ::int32_t net_read_timeout() const;
  void set_net_read_timeout(::int32_t value);

  private:
  ::int32_t _internal_net_read_timeout() const;
  void _internal_set_net_read_timeout(::int32_t value);

  public:
  // int32 net_write_timeout = 4;
  bool has_net_write_timeout() const;
  void clear_net_write_timeout() ;
  ::int32_t net_write_timeout() const;
  void set_net_write_timeout(::int32_t value);

  private:
  ::int32_t _internal_net_write_timeout() const;
  void _internal_set_net_write_timeout(::int32_t value);

  public:
  void clear_net_read_timeout_present();
  NetReadTimeoutPresentCase net_read_timeout_present_case() const;
  void clear_net_write_timeout_present();
  NetWriteTimeoutPresentCase net_write_timeout_present_case() const;
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.ClientAuth)
 private:
  class _Internal;
  void set_has_net_read_timeout();
  void set_has_net_write_timeout();

  inline bool has_net_read_timeout_present() const;
  inline void clear_has_net_read_timeout_present();

  inline bool has_net_write_timeout_present() const;
  inline void clear_has_net_write_timeout_present();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    ::int64_t start_timestamp_;
    union NetReadTimeoutPresentUnion {
      constexpr NetReadTimeoutPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int32_t net_read_timeout_;
    } net_read_timeout_present_;
    union NetWriteTimeoutPresentUnion {
      constexpr NetWriteTimeoutPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int32_t net_write_timeout_;
    } net_write_timeout_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Ack) */ {
 public:
  inline Ack() : Ack(nullptr) {}
  ~Ack() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ack(const Ack& from);
  Ack(Ack&& from) noexcept
    : Ack() {
    *this = ::std::move(from);
  }

  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ack& operator=(Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ack& default_instance() {
    return *internal_default_instance();
  }
  enum ErrorCodePresentCase {
    kErrorCode = 1,
    ERROR_CODE_PRESENT_NOT_SET = 0,
  };

  static inline const Ack* internal_default_instance() {
    return reinterpret_cast<const Ack*>(
               &_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Ack& a, Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ack& from) {
    Ack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Ack";
  }
  protected:
  explicit Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message() ;
  const std::string& error_message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* ptr);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // int32 error_code = 1;
  bool has_error_code() const;
  void clear_error_code() ;
  ::int32_t error_code() const;
  void set_error_code(::int32_t value);

  private:
  ::int32_t _internal_error_code() const;
  void _internal_set_error_code(::int32_t value);

  public:
  void clear_error_code_present();
  ErrorCodePresentCase error_code_present_case() const;
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Ack)
 private:
  class _Internal;
  void set_has_error_code();

  inline bool has_error_code_present() const;
  inline void clear_has_error_code_present();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    union ErrorCodePresentUnion {
      constexpr ErrorCodePresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int32_t error_code_;
    } error_code_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class ClientAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.ClientAck) */ {
 public:
  inline ClientAck() : ClientAck(nullptr) {}
  ~ClientAck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientAck(const ClientAck& from);
  ClientAck(ClientAck&& from) noexcept
    : ClientAck() {
    *this = ::std::move(from);
  }

  inline ClientAck& operator=(const ClientAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientAck& operator=(ClientAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientAck* internal_default_instance() {
    return reinterpret_cast<const ClientAck*>(
               &_ClientAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientAck& a, ClientAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientAck& from) {
    ClientAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.ClientAck";
  }
  protected:
  explicit ClientAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kBatchIdFieldNumber = 3,
  };
  // string destination = 1;
  void clear_destination() ;
  const std::string& destination() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // string client_id = 2;
  void clear_client_id() ;
  const std::string& client_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* ptr);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // int64 batch_id = 3;
  void clear_batch_id() ;
  ::int64_t batch_id() const;
  void set_batch_id(::int64_t value);

  private:
  ::int64_t _internal_batch_id() const;
  void _internal_set_batch_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.ClientAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::int64_t batch_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Sub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Sub) */ {
 public:
  inline Sub() : Sub(nullptr) {}
  ~Sub() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sub(const Sub& from);
  Sub(Sub&& from) noexcept
    : Sub() {
    *this = ::std::move(from);
  }

  inline Sub& operator=(const Sub& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sub& operator=(Sub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sub& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sub* internal_default_instance() {
    return reinterpret_cast<const Sub*>(
               &_Sub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Sub& a, Sub& b) {
    a.Swap(&b);
  }
  inline void Swap(Sub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sub* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sub& from) {
    Sub::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Sub";
  }
  protected:
  explicit Sub(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kFilterFieldNumber = 7,
  };
  // string destination = 1;
  void clear_destination() ;
  const std::string& destination() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // string client_id = 2;
  void clear_client_id() ;
  const std::string& client_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* ptr);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string filter = 7;
  void clear_filter() ;
  const std::string& filter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter(Arg_&& arg, Args_... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* ptr);

  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(
      const std::string& value);
  std::string* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Sub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Unsub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Unsub) */ {
 public:
  inline Unsub() : Unsub(nullptr) {}
  ~Unsub() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Unsub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Unsub(const Unsub& from);
  Unsub(Unsub&& from) noexcept
    : Unsub() {
    *this = ::std::move(from);
  }

  inline Unsub& operator=(const Unsub& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unsub& operator=(Unsub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unsub& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unsub* internal_default_instance() {
    return reinterpret_cast<const Unsub*>(
               &_Unsub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Unsub& a, Unsub& b) {
    a.Swap(&b);
  }
  inline void Swap(Unsub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unsub* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unsub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Unsub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Unsub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Unsub& from) {
    Unsub::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unsub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Unsub";
  }
  protected:
  explicit Unsub(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kFilterFieldNumber = 7,
  };
  // string destination = 1;
  void clear_destination() ;
  const std::string& destination() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // string client_id = 2;
  void clear_client_id() ;
  const std::string& client_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* ptr);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // string filter = 7;
  void clear_filter() ;
  const std::string& filter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter(Arg_&& arg, Args_... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* ptr);

  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(
      const std::string& value);
  std::string* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Unsub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Get final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Get) */ {
 public:
  inline Get() : Get(nullptr) {}
  ~Get() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Get(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Get(const Get& from);
  Get(Get&& from) noexcept
    : Get() {
    *this = ::std::move(from);
  }

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }
  inline Get& operator=(Get&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Get& default_instance() {
    return *internal_default_instance();
  }
  enum TimeoutPresentCase {
    kTimeout = 4,
    TIMEOUT_PRESENT_NOT_SET = 0,
  };

  enum UnitPresentCase {
    kUnit = 5,
    UNIT_PRESENT_NOT_SET = 0,
  };

  enum AutoAckPresentCase {
    kAutoAck = 6,
    AUTO_ACK_PRESENT_NOT_SET = 0,
  };

  static inline const Get* internal_default_instance() {
    return reinterpret_cast<const Get*>(
               &_Get_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Get& a, Get& b) {
    a.Swap(&b);
  }
  inline void Swap(Get* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Get* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Get* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Get>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Get& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Get& from) {
    Get::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Get* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Get";
  }
  protected:
  explicit Get(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kFetchSizeFieldNumber = 3,
    kTimeoutFieldNumber = 4,
    kUnitFieldNumber = 5,
    kAutoAckFieldNumber = 6,
  };
  // string destination = 1;
  void clear_destination() ;
  const std::string& destination() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // string client_id = 2;
  void clear_client_id() ;
  const std::string& client_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* ptr);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // int32 fetch_size = 3;
  void clear_fetch_size() ;
  ::int32_t fetch_size() const;
  void set_fetch_size(::int32_t value);

  private:
  ::int32_t _internal_fetch_size() const;
  void _internal_set_fetch_size(::int32_t value);

  public:
  // int64 timeout = 4;
  bool has_timeout() const;
  void clear_timeout() ;
  ::int64_t timeout() const;
  void set_timeout(::int64_t value);

  private:
  ::int64_t _internal_timeout() const;
  void _internal_set_timeout(::int64_t value);

  public:
  // int32 unit = 5;
  bool has_unit() const;
  void clear_unit() ;
  ::int32_t unit() const;
  void set_unit(::int32_t value);

  private:
  ::int32_t _internal_unit() const;
  void _internal_set_unit(::int32_t value);

  public:
  // bool auto_ack = 6;
  bool has_auto_ack() const;
  void clear_auto_ack() ;
  bool auto_ack() const;
  void set_auto_ack(bool value);

  private:
  bool _internal_auto_ack() const;
  void _internal_set_auto_ack(bool value);

  public:
  void clear_timeout_present();
  TimeoutPresentCase timeout_present_case() const;
  void clear_unit_present();
  UnitPresentCase unit_present_case() const;
  void clear_auto_ack_present();
  AutoAckPresentCase auto_ack_present_case() const;
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Get)
 private:
  class _Internal;
  void set_has_timeout();
  void set_has_unit();
  void set_has_auto_ack();

  inline bool has_timeout_present() const;
  inline void clear_has_timeout_present();

  inline bool has_unit_present() const;
  inline void clear_has_unit_present();

  inline bool has_auto_ack_present() const;
  inline void clear_has_auto_ack_present();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::int32_t fetch_size_;
    union TimeoutPresentUnion {
      constexpr TimeoutPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int64_t timeout_;
    } timeout_present_;
    union UnitPresentUnion {
      constexpr UnitPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int32_t unit_;
    } unit_present_;
    union AutoAckPresentUnion {
      constexpr AutoAckPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool auto_ack_;
    } auto_ack_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[3];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Messages final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Messages) */ {
 public:
  inline Messages() : Messages(nullptr) {}
  ~Messages() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Messages(const Messages& from);
  Messages(Messages&& from) noexcept
    : Messages() {
    *this = ::std::move(from);
  }

  inline Messages& operator=(const Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Messages& operator=(Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Messages& default_instance() {
    return *internal_default_instance();
  }
  static inline const Messages* internal_default_instance() {
    return reinterpret_cast<const Messages*>(
               &_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Messages& a, Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Messages* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Messages>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Messages& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Messages& from) {
    Messages::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Messages";
  }
  protected:
  explicit Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 2,
    kBatchIdFieldNumber = 1,
  };
  // repeated bytes messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;

  public:
  void clear_messages() ;
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  void set_messages(int index, const std::string& value);
  void set_messages(int index, std::string&& value);
  void set_messages(int index, const char* value);
  void set_messages(int index, const void* value, std::size_t size);
  void set_messages(int index, absl::string_view value);
  std::string* add_messages();
  void add_messages(const std::string& value);
  void add_messages(std::string&& value);
  void add_messages(const char* value);
  void add_messages(const void* value, std::size_t size);
  void add_messages(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messages();

  private:
  const std::string& _internal_messages(int index) const;
  std::string* _internal_add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_messages();

  public:
  // int64 batch_id = 1;
  void clear_batch_id() ;
  ::int64_t batch_id() const;
  void set_batch_id(::int64_t value);

  private:
  ::int64_t _internal_batch_id() const;
  void _internal_set_batch_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Messages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messages_;
    ::int64_t batch_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class Dump final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.Dump) */ {
 public:
  inline Dump() : Dump(nullptr) {}
  ~Dump() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dump(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dump(const Dump& from);
  Dump(Dump&& from) noexcept
    : Dump() {
    *this = ::std::move(from);
  }

  inline Dump& operator=(const Dump& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dump& operator=(Dump&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dump& default_instance() {
    return *internal_default_instance();
  }
  enum TimestampPresentCase {
    kTimestamp = 3,
    TIMESTAMP_PRESENT_NOT_SET = 0,
  };

  static inline const Dump* internal_default_instance() {
    return reinterpret_cast<const Dump*>(
               &_Dump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Dump& a, Dump& b) {
    a.Swap(&b);
  }
  inline void Swap(Dump* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dump* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dump>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dump& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dump& from) {
    Dump::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dump* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.Dump";
  }
  protected:
  explicit Dump(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJournalFieldNumber = 1,
    kPositionFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string journal = 1;
  void clear_journal() ;
  const std::string& journal() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_journal(Arg_&& arg, Args_... args);
  std::string* mutable_journal();
  PROTOBUF_NODISCARD std::string* release_journal();
  void set_allocated_journal(std::string* ptr);

  private:
  const std::string& _internal_journal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_journal(
      const std::string& value);
  std::string* _internal_mutable_journal();

  public:
  // int64 position = 2;
  void clear_position() ;
  ::int64_t position() const;
  void set_position(::int64_t value);

  private:
  ::int64_t _internal_position() const;
  void _internal_set_position(::int64_t value);

  public:
  // int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  void clear_timestamp_present();
  TimestampPresentCase timestamp_present_case() const;
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Dump)
 private:
  class _Internal;
  void set_has_timestamp();

  inline bool has_timestamp_present() const;
  inline void clear_has_timestamp_present();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr journal_;
    ::int64_t position_;
    union TimestampPresentUnion {
      constexpr TimestampPresentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::int64_t timestamp_;
    } timestamp_present_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};// -------------------------------------------------------------------

class ClientRollback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.alibaba.otter.canal.protocol.ClientRollback) */ {
 public:
  inline ClientRollback() : ClientRollback(nullptr) {}
  ~ClientRollback() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientRollback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientRollback(const ClientRollback& from);
  ClientRollback(ClientRollback&& from) noexcept
    : ClientRollback() {
    *this = ::std::move(from);
  }

  inline ClientRollback& operator=(const ClientRollback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientRollback& operator=(ClientRollback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientRollback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientRollback* internal_default_instance() {
    return reinterpret_cast<const ClientRollback*>(
               &_ClientRollback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClientRollback& a, ClientRollback& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientRollback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientRollback* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientRollback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientRollback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientRollback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientRollback& from) {
    ClientRollback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRollback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.alibaba.otter.canal.protocol.ClientRollback";
  }
  protected:
  explicit ClientRollback(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kBatchIdFieldNumber = 3,
  };
  // string destination = 1;
  void clear_destination() ;
  const std::string& destination() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination(Arg_&& arg, Args_... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* ptr);

  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(
      const std::string& value);
  std::string* _internal_mutable_destination();

  public:
  // string client_id = 2;
  void clear_client_id() ;
  const std::string& client_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* ptr);

  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(
      const std::string& value);
  std::string* _internal_mutable_client_id();

  public:
  // int64 batch_id = 3;
  void clear_batch_id() ;
  ::int64_t batch_id() const;
  void set_batch_id(::int64_t value);

  private:
  ::int64_t _internal_batch_id() const;
  void _internal_set_batch_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.ClientRollback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::int64_t batch_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CanalProtocol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Packet

// int32 magic_number = 1;
inline bool Packet::has_magic_number() const {
  return magic_number_present_case() == kMagicNumber;
}
inline void Packet::set_has_magic_number() {
  _impl_._oneof_case_[0] = kMagicNumber;
}
inline void Packet::clear_magic_number() {
  if (magic_number_present_case() == kMagicNumber) {
    _impl_.magic_number_present_.magic_number_ = 0;
    clear_has_magic_number_present();
  }
}
inline ::int32_t Packet::magic_number() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Packet.magic_number)
  return _internal_magic_number();
}
inline void Packet::set_magic_number(::int32_t value) {
  _internal_set_magic_number(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Packet.magic_number)
}
inline ::int32_t Packet::_internal_magic_number() const {
  if (magic_number_present_case() == kMagicNumber) {
    return _impl_.magic_number_present_.magic_number_;
  }
  return 0;
}
inline void Packet::_internal_set_magic_number(::int32_t value) {
  if (magic_number_present_case() != kMagicNumber) {
    clear_magic_number_present();
    set_has_magic_number();
  }
  _impl_.magic_number_present_.magic_number_ = value;
}

// int32 version = 2;
inline bool Packet::has_version() const {
  return version_present_case() == kVersion;
}
inline void Packet::set_has_version() {
  _impl_._oneof_case_[1] = kVersion;
}
inline void Packet::clear_version() {
  if (version_present_case() == kVersion) {
    _impl_.version_present_.version_ = 0;
    clear_has_version_present();
  }
}
inline ::int32_t Packet::version() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Packet.version)
  return _internal_version();
}
inline void Packet::set_version(::int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Packet.version)
}
inline ::int32_t Packet::_internal_version() const {
  if (version_present_case() == kVersion) {
    return _impl_.version_present_.version_;
  }
  return 0;
}
inline void Packet::_internal_set_version(::int32_t value) {
  if (version_present_case() != kVersion) {
    clear_version_present();
    set_has_version();
  }
  _impl_.version_present_.version_ = value;
}

// .com.alibaba.otter.canal.protocol.PacketType type = 3;
inline void Packet::clear_type() {
  _impl_.type_ = 0;
}
inline ::com::alibaba::otter::canal::protocol::PacketType Packet::type() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Packet.type)
  return _internal_type();
}
inline void Packet::set_type(::com::alibaba::otter::canal::protocol::PacketType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Packet.type)
}
inline ::com::alibaba::otter::canal::protocol::PacketType Packet::_internal_type() const {
  return static_cast<::com::alibaba::otter::canal::protocol::PacketType>(_impl_.type_);
}
inline void Packet::_internal_set_type(::com::alibaba::otter::canal::protocol::PacketType value) {
  ;
  _impl_.type_ = value;
}

// .com.alibaba.otter.canal.protocol.Compression compression = 4;
inline bool Packet::has_compression() const {
  return compression_present_case() == kCompression;
}
inline void Packet::set_has_compression() {
  _impl_._oneof_case_[2] = kCompression;
}
inline void Packet::clear_compression() {
  if (compression_present_case() == kCompression) {
    _impl_.compression_present_.compression_ = 0;
    clear_has_compression_present();
  }
}
inline ::com::alibaba::otter::canal::protocol::Compression Packet::compression() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Packet.compression)
  return _internal_compression();
}
inline void Packet::set_compression(::com::alibaba::otter::canal::protocol::Compression value) {
   _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Packet.compression)
}
inline ::com::alibaba::otter::canal::protocol::Compression Packet::_internal_compression() const {
  if (compression_present_case() == kCompression) {
    return static_cast<::com::alibaba::otter::canal::protocol::Compression>(_impl_.compression_present_.compression_);
  }
  return static_cast<::com::alibaba::otter::canal::protocol::Compression>(0);
}
inline void Packet::_internal_set_compression(::com::alibaba::otter::canal::protocol::Compression value) {
  if (compression_present_case() != kCompression) {
    clear_compression_present();
    set_has_compression();
  }
  _impl_.compression_present_.compression_ = value;
}

// bytes body = 5;
inline void Packet::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& Packet::body() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Packet.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Packet::set_body(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Packet.body)
}
inline std::string* Packet::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Packet.body)
  return _s;
}
inline const std::string& Packet::_internal_body() const {
  return _impl_.body_.Get();
}
inline void Packet::_internal_set_body(const std::string& value) {
  ;


  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* Packet::_internal_mutable_body() {
  ;
  return _impl_.body_.Mutable( GetArenaForAllocation());
}
inline std::string* Packet::release_body() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Packet.body)
  return _impl_.body_.Release();
}
inline void Packet::set_allocated_body(std::string* value) {
  _impl_.body_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Packet.body)
}

inline bool Packet::has_magic_number_present() const {
  return magic_number_present_case() != MAGIC_NUMBER_PRESENT_NOT_SET;
}
inline void Packet::clear_has_magic_number_present() {
  _impl_._oneof_case_[0] = MAGIC_NUMBER_PRESENT_NOT_SET;
}
inline bool Packet::has_version_present() const {
  return version_present_case() != VERSION_PRESENT_NOT_SET;
}
inline void Packet::clear_has_version_present() {
  _impl_._oneof_case_[1] = VERSION_PRESENT_NOT_SET;
}
inline bool Packet::has_compression_present() const {
  return compression_present_case() != COMPRESSION_PRESENT_NOT_SET;
}
inline void Packet::clear_has_compression_present() {
  _impl_._oneof_case_[2] = COMPRESSION_PRESENT_NOT_SET;
}
inline Packet::MagicNumberPresentCase Packet::magic_number_present_case() const {
  return Packet::MagicNumberPresentCase(_impl_._oneof_case_[0]);
}
inline Packet::VersionPresentCase Packet::version_present_case() const {
  return Packet::VersionPresentCase(_impl_._oneof_case_[1]);
}
inline Packet::CompressionPresentCase Packet::compression_present_case() const {
  return Packet::CompressionPresentCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// HeartBeat

// int64 send_timestamp = 1;
inline void HeartBeat::clear_send_timestamp() {
  _impl_.send_timestamp_ = ::int64_t{0};
}
inline ::int64_t HeartBeat::send_timestamp() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.HeartBeat.send_timestamp)
  return _internal_send_timestamp();
}
inline void HeartBeat::set_send_timestamp(::int64_t value) {
  _internal_set_send_timestamp(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.HeartBeat.send_timestamp)
}
inline ::int64_t HeartBeat::_internal_send_timestamp() const {
  return _impl_.send_timestamp_;
}
inline void HeartBeat::_internal_set_send_timestamp(::int64_t value) {
  ;
  _impl_.send_timestamp_ = value;
}

// int64 start_timestamp = 2;
inline void HeartBeat::clear_start_timestamp() {
  _impl_.start_timestamp_ = ::int64_t{0};
}
inline ::int64_t HeartBeat::start_timestamp() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.HeartBeat.start_timestamp)
  return _internal_start_timestamp();
}
inline void HeartBeat::set_start_timestamp(::int64_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.HeartBeat.start_timestamp)
}
inline ::int64_t HeartBeat::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline void HeartBeat::_internal_set_start_timestamp(::int64_t value) {
  ;
  _impl_.start_timestamp_ = value;
}

// -------------------------------------------------------------------

// Handshake

// string communication_encoding = 1;
inline bool Handshake::has_communication_encoding() const {
  return communication_encoding_present_case() == kCommunicationEncoding;
}
inline void Handshake::set_has_communication_encoding() {
  _impl_._oneof_case_[0] = kCommunicationEncoding;
}
inline void Handshake::clear_communication_encoding() {
  if (communication_encoding_present_case() == kCommunicationEncoding) {
    _impl_.communication_encoding_present_.communication_encoding_.Destroy();
    clear_has_communication_encoding_present();
  }
}
inline const std::string& Handshake::communication_encoding() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Handshake.communication_encoding)
  return _internal_communication_encoding();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_communication_encoding(Arg_&& arg,
                                                     Args_... args) {
  if (communication_encoding_present_case() != kCommunicationEncoding) {
    clear_communication_encoding_present();

    set_has_communication_encoding();
    _impl_.communication_encoding_present_.communication_encoding_.InitDefault();
  }
  _impl_.communication_encoding_present_.communication_encoding_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Handshake.communication_encoding)
}
inline std::string* Handshake::mutable_communication_encoding() {
  std::string* _s = _internal_mutable_communication_encoding();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Handshake.communication_encoding)
  return _s;
}
inline const std::string& Handshake::_internal_communication_encoding() const {
  if (communication_encoding_present_case() != kCommunicationEncoding) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.communication_encoding_present_.communication_encoding_.Get();
}
inline void Handshake::_internal_set_communication_encoding(const std::string& value) {
  if (communication_encoding_present_case() != kCommunicationEncoding) {
    clear_communication_encoding_present();

    set_has_communication_encoding();
    _impl_.communication_encoding_present_.communication_encoding_.InitDefault();
  }


  _impl_.communication_encoding_present_.communication_encoding_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_communication_encoding() {
  if (communication_encoding_present_case() != kCommunicationEncoding) {
    clear_communication_encoding_present();

    set_has_communication_encoding();
    _impl_.communication_encoding_present_.communication_encoding_.InitDefault();
  }
  return _impl_.communication_encoding_present_.communication_encoding_.Mutable( GetArenaForAllocation());
}
inline std::string* Handshake::release_communication_encoding() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Handshake.communication_encoding)
  if (communication_encoding_present_case() != kCommunicationEncoding) {
    return nullptr;
  }
  clear_has_communication_encoding_present();
  return _impl_.communication_encoding_present_.communication_encoding_.Release();
}
inline void Handshake::set_allocated_communication_encoding(std::string* value) {
  if (has_communication_encoding_present()) {
    clear_communication_encoding_present();
  }
  if (value != nullptr) {
    set_has_communication_encoding();
    _impl_.communication_encoding_present_.communication_encoding_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Handshake.communication_encoding)
}

// bytes seeds = 2;
inline void Handshake::clear_seeds() {
  _impl_.seeds_.ClearToEmpty();
}
inline const std::string& Handshake::seeds() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Handshake.seeds)
  return _internal_seeds();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_seeds(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.seeds_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Handshake.seeds)
}
inline std::string* Handshake::mutable_seeds() {
  std::string* _s = _internal_mutable_seeds();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Handshake.seeds)
  return _s;
}
inline const std::string& Handshake::_internal_seeds() const {
  return _impl_.seeds_.Get();
}
inline void Handshake::_internal_set_seeds(const std::string& value) {
  ;


  _impl_.seeds_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_seeds() {
  ;
  return _impl_.seeds_.Mutable( GetArenaForAllocation());
}
inline std::string* Handshake::release_seeds() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Handshake.seeds)
  return _impl_.seeds_.Release();
}
inline void Handshake::set_allocated_seeds(std::string* value) {
  _impl_.seeds_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.seeds_.IsDefault()) {
          _impl_.seeds_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Handshake.seeds)
}

// .com.alibaba.otter.canal.protocol.Compression supported_compressions = 3;
inline void Handshake::clear_supported_compressions() {
  _impl_.supported_compressions_ = 0;
}
inline ::com::alibaba::otter::canal::protocol::Compression Handshake::supported_compressions() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Handshake.supported_compressions)
  return _internal_supported_compressions();
}
inline void Handshake::set_supported_compressions(::com::alibaba::otter::canal::protocol::Compression value) {
   _internal_set_supported_compressions(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Handshake.supported_compressions)
}
inline ::com::alibaba::otter::canal::protocol::Compression Handshake::_internal_supported_compressions() const {
  return static_cast<::com::alibaba::otter::canal::protocol::Compression>(_impl_.supported_compressions_);
}
inline void Handshake::_internal_set_supported_compressions(::com::alibaba::otter::canal::protocol::Compression value) {
  ;
  _impl_.supported_compressions_ = value;
}

inline bool Handshake::has_communication_encoding_present() const {
  return communication_encoding_present_case() != COMMUNICATION_ENCODING_PRESENT_NOT_SET;
}
inline void Handshake::clear_has_communication_encoding_present() {
  _impl_._oneof_case_[0] = COMMUNICATION_ENCODING_PRESENT_NOT_SET;
}
inline Handshake::CommunicationEncodingPresentCase Handshake::communication_encoding_present_case() const {
  return Handshake::CommunicationEncodingPresentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientAuth

// string username = 1;
inline void ClientAuth::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ClientAuth::username() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAuth::set_username(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.username)
}
inline std::string* ClientAuth::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAuth.username)
  return _s;
}
inline const std::string& ClientAuth::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ClientAuth::_internal_set_username(const std::string& value) {
  ;


  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAuth::_internal_mutable_username() {
  ;
  return _impl_.username_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAuth::release_username() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAuth.username)
  return _impl_.username_.Release();
}
inline void ClientAuth::set_allocated_username(std::string* value) {
  _impl_.username_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAuth.username)
}

// bytes password = 2;
inline void ClientAuth::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& ClientAuth::password() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAuth::set_password(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.password_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.password)
}
inline std::string* ClientAuth::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAuth.password)
  return _s;
}
inline const std::string& ClientAuth::_internal_password() const {
  return _impl_.password_.Get();
}
inline void ClientAuth::_internal_set_password(const std::string& value) {
  ;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAuth::_internal_mutable_password() {
  ;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAuth::release_password() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAuth.password)
  return _impl_.password_.Release();
}
inline void ClientAuth::set_allocated_password(std::string* value) {
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAuth.password)
}

// int32 net_read_timeout = 3;
inline bool ClientAuth::has_net_read_timeout() const {
  return net_read_timeout_present_case() == kNetReadTimeout;
}
inline void ClientAuth::set_has_net_read_timeout() {
  _impl_._oneof_case_[0] = kNetReadTimeout;
}
inline void ClientAuth::clear_net_read_timeout() {
  if (net_read_timeout_present_case() == kNetReadTimeout) {
    _impl_.net_read_timeout_present_.net_read_timeout_ = 0;
    clear_has_net_read_timeout_present();
  }
}
inline ::int32_t ClientAuth::net_read_timeout() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.net_read_timeout)
  return _internal_net_read_timeout();
}
inline void ClientAuth::set_net_read_timeout(::int32_t value) {
  _internal_set_net_read_timeout(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.net_read_timeout)
}
inline ::int32_t ClientAuth::_internal_net_read_timeout() const {
  if (net_read_timeout_present_case() == kNetReadTimeout) {
    return _impl_.net_read_timeout_present_.net_read_timeout_;
  }
  return 0;
}
inline void ClientAuth::_internal_set_net_read_timeout(::int32_t value) {
  if (net_read_timeout_present_case() != kNetReadTimeout) {
    clear_net_read_timeout_present();
    set_has_net_read_timeout();
  }
  _impl_.net_read_timeout_present_.net_read_timeout_ = value;
}

// int32 net_write_timeout = 4;
inline bool ClientAuth::has_net_write_timeout() const {
  return net_write_timeout_present_case() == kNetWriteTimeout;
}
inline void ClientAuth::set_has_net_write_timeout() {
  _impl_._oneof_case_[1] = kNetWriteTimeout;
}
inline void ClientAuth::clear_net_write_timeout() {
  if (net_write_timeout_present_case() == kNetWriteTimeout) {
    _impl_.net_write_timeout_present_.net_write_timeout_ = 0;
    clear_has_net_write_timeout_present();
  }
}
inline ::int32_t ClientAuth::net_write_timeout() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.net_write_timeout)
  return _internal_net_write_timeout();
}
inline void ClientAuth::set_net_write_timeout(::int32_t value) {
  _internal_set_net_write_timeout(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.net_write_timeout)
}
inline ::int32_t ClientAuth::_internal_net_write_timeout() const {
  if (net_write_timeout_present_case() == kNetWriteTimeout) {
    return _impl_.net_write_timeout_present_.net_write_timeout_;
  }
  return 0;
}
inline void ClientAuth::_internal_set_net_write_timeout(::int32_t value) {
  if (net_write_timeout_present_case() != kNetWriteTimeout) {
    clear_net_write_timeout_present();
    set_has_net_write_timeout();
  }
  _impl_.net_write_timeout_present_.net_write_timeout_ = value;
}

// string destination = 5;
inline void ClientAuth::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& ClientAuth::destination() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAuth::set_destination(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.destination)
}
inline std::string* ClientAuth::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAuth.destination)
  return _s;
}
inline const std::string& ClientAuth::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void ClientAuth::_internal_set_destination(const std::string& value) {
  ;


  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAuth::_internal_mutable_destination() {
  ;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAuth::release_destination() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAuth.destination)
  return _impl_.destination_.Release();
}
inline void ClientAuth::set_allocated_destination(std::string* value) {
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAuth.destination)
}

// string client_id = 6;
inline void ClientAuth::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& ClientAuth::client_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAuth::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.client_id)
}
inline std::string* ClientAuth::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAuth.client_id)
  return _s;
}
inline const std::string& ClientAuth::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void ClientAuth::_internal_set_client_id(const std::string& value) {
  ;


  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAuth::_internal_mutable_client_id() {
  ;
  return _impl_.client_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAuth::release_client_id() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAuth.client_id)
  return _impl_.client_id_.Release();
}
inline void ClientAuth::set_allocated_client_id(std::string* value) {
  _impl_.client_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAuth.client_id)
}

// string filter = 7;
inline void ClientAuth::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ClientAuth::filter() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.filter)
  return _internal_filter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAuth::set_filter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.filter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.filter)
}
inline std::string* ClientAuth::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAuth.filter)
  return _s;
}
inline const std::string& ClientAuth::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ClientAuth::_internal_set_filter(const std::string& value) {
  ;


  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAuth::_internal_mutable_filter() {
  ;
  return _impl_.filter_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAuth::release_filter() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAuth.filter)
  return _impl_.filter_.Release();
}
inline void ClientAuth::set_allocated_filter(std::string* value) {
  _impl_.filter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filter_.IsDefault()) {
          _impl_.filter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAuth.filter)
}

// int64 start_timestamp = 8;
inline void ClientAuth::clear_start_timestamp() {
  _impl_.start_timestamp_ = ::int64_t{0};
}
inline ::int64_t ClientAuth::start_timestamp() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAuth.start_timestamp)
  return _internal_start_timestamp();
}
inline void ClientAuth::set_start_timestamp(::int64_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAuth.start_timestamp)
}
inline ::int64_t ClientAuth::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline void ClientAuth::_internal_set_start_timestamp(::int64_t value) {
  ;
  _impl_.start_timestamp_ = value;
}

inline bool ClientAuth::has_net_read_timeout_present() const {
  return net_read_timeout_present_case() != NET_READ_TIMEOUT_PRESENT_NOT_SET;
}
inline void ClientAuth::clear_has_net_read_timeout_present() {
  _impl_._oneof_case_[0] = NET_READ_TIMEOUT_PRESENT_NOT_SET;
}
inline bool ClientAuth::has_net_write_timeout_present() const {
  return net_write_timeout_present_case() != NET_WRITE_TIMEOUT_PRESENT_NOT_SET;
}
inline void ClientAuth::clear_has_net_write_timeout_present() {
  _impl_._oneof_case_[1] = NET_WRITE_TIMEOUT_PRESENT_NOT_SET;
}
inline ClientAuth::NetReadTimeoutPresentCase ClientAuth::net_read_timeout_present_case() const {
  return ClientAuth::NetReadTimeoutPresentCase(_impl_._oneof_case_[0]);
}
inline ClientAuth::NetWriteTimeoutPresentCase ClientAuth::net_write_timeout_present_case() const {
  return ClientAuth::NetWriteTimeoutPresentCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Ack

// int32 error_code = 1;
inline bool Ack::has_error_code() const {
  return error_code_present_case() == kErrorCode;
}
inline void Ack::set_has_error_code() {
  _impl_._oneof_case_[0] = kErrorCode;
}
inline void Ack::clear_error_code() {
  if (error_code_present_case() == kErrorCode) {
    _impl_.error_code_present_.error_code_ = 0;
    clear_has_error_code_present();
  }
}
inline ::int32_t Ack::error_code() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Ack.error_code)
  return _internal_error_code();
}
inline void Ack::set_error_code(::int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Ack.error_code)
}
inline ::int32_t Ack::_internal_error_code() const {
  if (error_code_present_case() == kErrorCode) {
    return _impl_.error_code_present_.error_code_;
  }
  return 0;
}
inline void Ack::_internal_set_error_code(::int32_t value) {
  if (error_code_present_case() != kErrorCode) {
    clear_error_code_present();
    set_has_error_code();
  }
  _impl_.error_code_present_.error_code_ = value;
}

// string error_message = 2;
inline void Ack::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& Ack::error_message() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Ack.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Ack::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Ack.error_message)
}
inline std::string* Ack::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Ack.error_message)
  return _s;
}
inline const std::string& Ack::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void Ack::_internal_set_error_message(const std::string& value) {
  ;


  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* Ack::_internal_mutable_error_message() {
  ;
  return _impl_.error_message_.Mutable( GetArenaForAllocation());
}
inline std::string* Ack::release_error_message() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Ack.error_message)
  return _impl_.error_message_.Release();
}
inline void Ack::set_allocated_error_message(std::string* value) {
  _impl_.error_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Ack.error_message)
}

inline bool Ack::has_error_code_present() const {
  return error_code_present_case() != ERROR_CODE_PRESENT_NOT_SET;
}
inline void Ack::clear_has_error_code_present() {
  _impl_._oneof_case_[0] = ERROR_CODE_PRESENT_NOT_SET;
}
inline Ack::ErrorCodePresentCase Ack::error_code_present_case() const {
  return Ack::ErrorCodePresentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientAck

// string destination = 1;
inline void ClientAck::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& ClientAck::destination() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAck.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAck::set_destination(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAck.destination)
}
inline std::string* ClientAck::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAck.destination)
  return _s;
}
inline const std::string& ClientAck::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void ClientAck::_internal_set_destination(const std::string& value) {
  ;


  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAck::_internal_mutable_destination() {
  ;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAck::release_destination() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAck.destination)
  return _impl_.destination_.Release();
}
inline void ClientAck::set_allocated_destination(std::string* value) {
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAck.destination)
}

// string client_id = 2;
inline void ClientAck::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& ClientAck::client_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAck.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientAck::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAck.client_id)
}
inline std::string* ClientAck::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientAck.client_id)
  return _s;
}
inline const std::string& ClientAck::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void ClientAck::_internal_set_client_id(const std::string& value) {
  ;


  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAck::_internal_mutable_client_id() {
  ;
  return _impl_.client_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientAck::release_client_id() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientAck.client_id)
  return _impl_.client_id_.Release();
}
inline void ClientAck::set_allocated_client_id(std::string* value) {
  _impl_.client_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientAck.client_id)
}

// int64 batch_id = 3;
inline void ClientAck::clear_batch_id() {
  _impl_.batch_id_ = ::int64_t{0};
}
inline ::int64_t ClientAck::batch_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientAck.batch_id)
  return _internal_batch_id();
}
inline void ClientAck::set_batch_id(::int64_t value) {
  _internal_set_batch_id(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientAck.batch_id)
}
inline ::int64_t ClientAck::_internal_batch_id() const {
  return _impl_.batch_id_;
}
inline void ClientAck::_internal_set_batch_id(::int64_t value) {
  ;
  _impl_.batch_id_ = value;
}

// -------------------------------------------------------------------

// Sub

// string destination = 1;
inline void Sub::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& Sub::destination() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Sub.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Sub::set_destination(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Sub.destination)
}
inline std::string* Sub::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Sub.destination)
  return _s;
}
inline const std::string& Sub::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void Sub::_internal_set_destination(const std::string& value) {
  ;


  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* Sub::_internal_mutable_destination() {
  ;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* Sub::release_destination() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Sub.destination)
  return _impl_.destination_.Release();
}
inline void Sub::set_allocated_destination(std::string* value) {
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Sub.destination)
}

// string client_id = 2;
inline void Sub::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& Sub::client_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Sub.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Sub::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Sub.client_id)
}
inline std::string* Sub::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Sub.client_id)
  return _s;
}
inline const std::string& Sub::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void Sub::_internal_set_client_id(const std::string& value) {
  ;


  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Sub::_internal_mutable_client_id() {
  ;
  return _impl_.client_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Sub::release_client_id() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Sub.client_id)
  return _impl_.client_id_.Release();
}
inline void Sub::set_allocated_client_id(std::string* value) {
  _impl_.client_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Sub.client_id)
}

// string filter = 7;
inline void Sub::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& Sub::filter() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Sub.filter)
  return _internal_filter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Sub::set_filter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.filter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Sub.filter)
}
inline std::string* Sub::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Sub.filter)
  return _s;
}
inline const std::string& Sub::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void Sub::_internal_set_filter(const std::string& value) {
  ;


  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* Sub::_internal_mutable_filter() {
  ;
  return _impl_.filter_.Mutable( GetArenaForAllocation());
}
inline std::string* Sub::release_filter() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Sub.filter)
  return _impl_.filter_.Release();
}
inline void Sub::set_allocated_filter(std::string* value) {
  _impl_.filter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filter_.IsDefault()) {
          _impl_.filter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Sub.filter)
}

// -------------------------------------------------------------------

// Unsub

// string destination = 1;
inline void Unsub::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& Unsub::destination() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Unsub.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Unsub::set_destination(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Unsub.destination)
}
inline std::string* Unsub::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Unsub.destination)
  return _s;
}
inline const std::string& Unsub::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void Unsub::_internal_set_destination(const std::string& value) {
  ;


  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* Unsub::_internal_mutable_destination() {
  ;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* Unsub::release_destination() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Unsub.destination)
  return _impl_.destination_.Release();
}
inline void Unsub::set_allocated_destination(std::string* value) {
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Unsub.destination)
}

// string client_id = 2;
inline void Unsub::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& Unsub::client_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Unsub.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Unsub::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Unsub.client_id)
}
inline std::string* Unsub::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Unsub.client_id)
  return _s;
}
inline const std::string& Unsub::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void Unsub::_internal_set_client_id(const std::string& value) {
  ;


  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Unsub::_internal_mutable_client_id() {
  ;
  return _impl_.client_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Unsub::release_client_id() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Unsub.client_id)
  return _impl_.client_id_.Release();
}
inline void Unsub::set_allocated_client_id(std::string* value) {
  _impl_.client_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Unsub.client_id)
}

// string filter = 7;
inline void Unsub::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& Unsub::filter() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Unsub.filter)
  return _internal_filter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Unsub::set_filter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.filter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Unsub.filter)
}
inline std::string* Unsub::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Unsub.filter)
  return _s;
}
inline const std::string& Unsub::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void Unsub::_internal_set_filter(const std::string& value) {
  ;


  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* Unsub::_internal_mutable_filter() {
  ;
  return _impl_.filter_.Mutable( GetArenaForAllocation());
}
inline std::string* Unsub::release_filter() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Unsub.filter)
  return _impl_.filter_.Release();
}
inline void Unsub::set_allocated_filter(std::string* value) {
  _impl_.filter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filter_.IsDefault()) {
          _impl_.filter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Unsub.filter)
}

// -------------------------------------------------------------------

// Get

// string destination = 1;
inline void Get::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& Get::destination() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Get.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Get::set_destination(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Get.destination)
}
inline std::string* Get::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Get.destination)
  return _s;
}
inline const std::string& Get::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void Get::_internal_set_destination(const std::string& value) {
  ;


  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* Get::_internal_mutable_destination() {
  ;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* Get::release_destination() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Get.destination)
  return _impl_.destination_.Release();
}
inline void Get::set_allocated_destination(std::string* value) {
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Get.destination)
}

// string client_id = 2;
inline void Get::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& Get::client_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Get.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Get::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Get.client_id)
}
inline std::string* Get::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Get.client_id)
  return _s;
}
inline const std::string& Get::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void Get::_internal_set_client_id(const std::string& value) {
  ;


  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Get::_internal_mutable_client_id() {
  ;
  return _impl_.client_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Get::release_client_id() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Get.client_id)
  return _impl_.client_id_.Release();
}
inline void Get::set_allocated_client_id(std::string* value) {
  _impl_.client_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Get.client_id)
}

// int32 fetch_size = 3;
inline void Get::clear_fetch_size() {
  _impl_.fetch_size_ = 0;
}
inline ::int32_t Get::fetch_size() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Get.fetch_size)
  return _internal_fetch_size();
}
inline void Get::set_fetch_size(::int32_t value) {
  _internal_set_fetch_size(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Get.fetch_size)
}
inline ::int32_t Get::_internal_fetch_size() const {
  return _impl_.fetch_size_;
}
inline void Get::_internal_set_fetch_size(::int32_t value) {
  ;
  _impl_.fetch_size_ = value;
}

// int64 timeout = 4;
inline bool Get::has_timeout() const {
  return timeout_present_case() == kTimeout;
}
inline void Get::set_has_timeout() {
  _impl_._oneof_case_[0] = kTimeout;
}
inline void Get::clear_timeout() {
  if (timeout_present_case() == kTimeout) {
    _impl_.timeout_present_.timeout_ = ::int64_t{0};
    clear_has_timeout_present();
  }
}
inline ::int64_t Get::timeout() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Get.timeout)
  return _internal_timeout();
}
inline void Get::set_timeout(::int64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Get.timeout)
}
inline ::int64_t Get::_internal_timeout() const {
  if (timeout_present_case() == kTimeout) {
    return _impl_.timeout_present_.timeout_;
  }
  return ::int64_t{0};
}
inline void Get::_internal_set_timeout(::int64_t value) {
  if (timeout_present_case() != kTimeout) {
    clear_timeout_present();
    set_has_timeout();
  }
  _impl_.timeout_present_.timeout_ = value;
}

// int32 unit = 5;
inline bool Get::has_unit() const {
  return unit_present_case() == kUnit;
}
inline void Get::set_has_unit() {
  _impl_._oneof_case_[1] = kUnit;
}
inline void Get::clear_unit() {
  if (unit_present_case() == kUnit) {
    _impl_.unit_present_.unit_ = 0;
    clear_has_unit_present();
  }
}
inline ::int32_t Get::unit() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Get.unit)
  return _internal_unit();
}
inline void Get::set_unit(::int32_t value) {
  _internal_set_unit(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Get.unit)
}
inline ::int32_t Get::_internal_unit() const {
  if (unit_present_case() == kUnit) {
    return _impl_.unit_present_.unit_;
  }
  return 0;
}
inline void Get::_internal_set_unit(::int32_t value) {
  if (unit_present_case() != kUnit) {
    clear_unit_present();
    set_has_unit();
  }
  _impl_.unit_present_.unit_ = value;
}

// bool auto_ack = 6;
inline bool Get::has_auto_ack() const {
  return auto_ack_present_case() == kAutoAck;
}
inline void Get::set_has_auto_ack() {
  _impl_._oneof_case_[2] = kAutoAck;
}
inline void Get::clear_auto_ack() {
  if (auto_ack_present_case() == kAutoAck) {
    _impl_.auto_ack_present_.auto_ack_ = false;
    clear_has_auto_ack_present();
  }
}
inline bool Get::auto_ack() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Get.auto_ack)
  return _internal_auto_ack();
}
inline void Get::set_auto_ack(bool value) {
  _internal_set_auto_ack(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Get.auto_ack)
}
inline bool Get::_internal_auto_ack() const {
  if (auto_ack_present_case() == kAutoAck) {
    return _impl_.auto_ack_present_.auto_ack_;
  }
  return false;
}
inline void Get::_internal_set_auto_ack(bool value) {
  if (auto_ack_present_case() != kAutoAck) {
    clear_auto_ack_present();
    set_has_auto_ack();
  }
  _impl_.auto_ack_present_.auto_ack_ = value;
}

inline bool Get::has_timeout_present() const {
  return timeout_present_case() != TIMEOUT_PRESENT_NOT_SET;
}
inline void Get::clear_has_timeout_present() {
  _impl_._oneof_case_[0] = TIMEOUT_PRESENT_NOT_SET;
}
inline bool Get::has_unit_present() const {
  return unit_present_case() != UNIT_PRESENT_NOT_SET;
}
inline void Get::clear_has_unit_present() {
  _impl_._oneof_case_[1] = UNIT_PRESENT_NOT_SET;
}
inline bool Get::has_auto_ack_present() const {
  return auto_ack_present_case() != AUTO_ACK_PRESENT_NOT_SET;
}
inline void Get::clear_has_auto_ack_present() {
  _impl_._oneof_case_[2] = AUTO_ACK_PRESENT_NOT_SET;
}
inline Get::TimeoutPresentCase Get::timeout_present_case() const {
  return Get::TimeoutPresentCase(_impl_._oneof_case_[0]);
}
inline Get::UnitPresentCase Get::unit_present_case() const {
  return Get::UnitPresentCase(_impl_._oneof_case_[1]);
}
inline Get::AutoAckPresentCase Get::auto_ack_present_case() const {
  return Get::AutoAckPresentCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// Messages

// int64 batch_id = 1;
inline void Messages::clear_batch_id() {
  _impl_.batch_id_ = ::int64_t{0};
}
inline ::int64_t Messages::batch_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Messages.batch_id)
  return _internal_batch_id();
}
inline void Messages::set_batch_id(::int64_t value) {
  _internal_set_batch_id(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Messages.batch_id)
}
inline ::int64_t Messages::_internal_batch_id() const {
  return _impl_.batch_id_;
}
inline void Messages::_internal_set_batch_id(::int64_t value) {
  ;
  _impl_.batch_id_ = value;
}

// repeated bytes messages = 2;
inline int Messages::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int Messages::messages_size() const {
  return _internal_messages_size();
}
inline void Messages::clear_messages() {
  _internal_mutable_messages()->Clear();
}
inline std::string* Messages::add_messages() {
  std::string* _s = _internal_add_messages();
  // @@protoc_insertion_point(field_add_mutable:com.alibaba.otter.canal.protocol.Messages.messages)
  return _s;
}
inline const std::string& Messages::messages(int index) const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Messages.messages)
  return _internal_messages(index);
}
inline std::string* Messages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Messages.messages)
  return _internal_mutable_messages()->Mutable(index);
}
inline void Messages::set_messages(int index, const std::string& value) {
  _internal_mutable_messages()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::set_messages(int index, std::string&& value) {
  _internal_mutable_messages()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::set_messages(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_messages()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::set_messages(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_messages()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::set_messages(int index, absl::string_view value) {
  _internal_mutable_messages()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::add_messages(const std::string& value) {
  _internal_mutable_messages()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::add_messages(std::string&& value) {
  _internal_mutable_messages()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::add_messages(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_messages()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::add_messages(const void* value, std::size_t size) {
  _internal_mutable_messages()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline void Messages::add_messages(absl::string_view value) {
  _internal_mutable_messages()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:com.alibaba.otter.canal.protocol.Messages.messages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Messages::messages() const {
  // @@protoc_insertion_point(field_list:com.alibaba.otter.canal.protocol.Messages.messages)
  return _internal_messages();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Messages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:com.alibaba.otter.canal.protocol.Messages.messages)
  return _internal_mutable_messages();
}
inline const std::string& Messages::_internal_messages(int index) const {
  return _internal_messages().Get(index);
}
inline std::string* Messages::_internal_add_messages() {
  return _internal_mutable_messages()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Messages::_internal_messages() const {
  return _impl_.messages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Messages::_internal_mutable_messages() {
  return &_impl_.messages_;
}

// -------------------------------------------------------------------

// Dump

// string journal = 1;
inline void Dump::clear_journal() {
  _impl_.journal_.ClearToEmpty();
}
inline const std::string& Dump::journal() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Dump.journal)
  return _internal_journal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Dump::set_journal(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.journal_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Dump.journal)
}
inline std::string* Dump::mutable_journal() {
  std::string* _s = _internal_mutable_journal();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.Dump.journal)
  return _s;
}
inline const std::string& Dump::_internal_journal() const {
  return _impl_.journal_.Get();
}
inline void Dump::_internal_set_journal(const std::string& value) {
  ;


  _impl_.journal_.Set(value, GetArenaForAllocation());
}
inline std::string* Dump::_internal_mutable_journal() {
  ;
  return _impl_.journal_.Mutable( GetArenaForAllocation());
}
inline std::string* Dump::release_journal() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.Dump.journal)
  return _impl_.journal_.Release();
}
inline void Dump::set_allocated_journal(std::string* value) {
  _impl_.journal_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.journal_.IsDefault()) {
          _impl_.journal_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.Dump.journal)
}

// int64 position = 2;
inline void Dump::clear_position() {
  _impl_.position_ = ::int64_t{0};
}
inline ::int64_t Dump::position() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Dump.position)
  return _internal_position();
}
inline void Dump::set_position(::int64_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Dump.position)
}
inline ::int64_t Dump::_internal_position() const {
  return _impl_.position_;
}
inline void Dump::_internal_set_position(::int64_t value) {
  ;
  _impl_.position_ = value;
}

// int64 timestamp = 3;
inline bool Dump::has_timestamp() const {
  return timestamp_present_case() == kTimestamp;
}
inline void Dump::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline void Dump::clear_timestamp() {
  if (timestamp_present_case() == kTimestamp) {
    _impl_.timestamp_present_.timestamp_ = ::int64_t{0};
    clear_has_timestamp_present();
  }
}
inline ::int64_t Dump::timestamp() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.Dump.timestamp)
  return _internal_timestamp();
}
inline void Dump::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.Dump.timestamp)
}
inline ::int64_t Dump::_internal_timestamp() const {
  if (timestamp_present_case() == kTimestamp) {
    return _impl_.timestamp_present_.timestamp_;
  }
  return ::int64_t{0};
}
inline void Dump::_internal_set_timestamp(::int64_t value) {
  if (timestamp_present_case() != kTimestamp) {
    clear_timestamp_present();
    set_has_timestamp();
  }
  _impl_.timestamp_present_.timestamp_ = value;
}

inline bool Dump::has_timestamp_present() const {
  return timestamp_present_case() != TIMESTAMP_PRESENT_NOT_SET;
}
inline void Dump::clear_has_timestamp_present() {
  _impl_._oneof_case_[0] = TIMESTAMP_PRESENT_NOT_SET;
}
inline Dump::TimestampPresentCase Dump::timestamp_present_case() const {
  return Dump::TimestampPresentCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientRollback

// string destination = 1;
inline void ClientRollback::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& ClientRollback::destination() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientRollback.destination)
  return _internal_destination();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientRollback::set_destination(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientRollback.destination)
}
inline std::string* ClientRollback::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientRollback.destination)
  return _s;
}
inline const std::string& ClientRollback::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void ClientRollback::_internal_set_destination(const std::string& value) {
  ;


  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientRollback::_internal_mutable_destination() {
  ;
  return _impl_.destination_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientRollback::release_destination() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientRollback.destination)
  return _impl_.destination_.Release();
}
inline void ClientRollback::set_allocated_destination(std::string* value) {
  _impl_.destination_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_.IsDefault()) {
          _impl_.destination_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientRollback.destination)
}

// string client_id = 2;
inline void ClientRollback::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& ClientRollback::client_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientRollback.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientRollback::set_client_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientRollback.client_id)
}
inline std::string* ClientRollback::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:com.alibaba.otter.canal.protocol.ClientRollback.client_id)
  return _s;
}
inline const std::string& ClientRollback::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void ClientRollback::_internal_set_client_id(const std::string& value) {
  ;


  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientRollback::_internal_mutable_client_id() {
  ;
  return _impl_.client_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientRollback::release_client_id() {
  // @@protoc_insertion_point(field_release:com.alibaba.otter.canal.protocol.ClientRollback.client_id)
  return _impl_.client_id_.Release();
}
inline void ClientRollback::set_allocated_client_id(std::string* value) {
  _impl_.client_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_id_.IsDefault()) {
          _impl_.client_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.alibaba.otter.canal.protocol.ClientRollback.client_id)
}

// int64 batch_id = 3;
inline void ClientRollback::clear_batch_id() {
  _impl_.batch_id_ = ::int64_t{0};
}
inline ::int64_t ClientRollback::batch_id() const {
  // @@protoc_insertion_point(field_get:com.alibaba.otter.canal.protocol.ClientRollback.batch_id)
  return _internal_batch_id();
}
inline void ClientRollback::set_batch_id(::int64_t value) {
  _internal_set_batch_id(value);
  // @@protoc_insertion_point(field_set:com.alibaba.otter.canal.protocol.ClientRollback.batch_id)
}
inline ::int64_t ClientRollback::_internal_batch_id() const {
  return _impl_.batch_id_;
}
inline void ClientRollback::_internal_set_batch_id(::int64_t value) {
  ;
  _impl_.batch_id_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
}  // namespace canal
}  // namespace otter
}  // namespace alibaba
}  // namespace com


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::com::alibaba::otter::canal::protocol::Compression> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::alibaba::otter::canal::protocol::Compression>() {
  return ::com::alibaba::otter::canal::protocol::Compression_descriptor();
}
template <>
struct is_proto_enum<::com::alibaba::otter::canal::protocol::PacketType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::alibaba::otter::canal::protocol::PacketType>() {
  return ::com::alibaba::otter::canal::protocol::PacketType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_CanalProtocol_2eproto_2epb_2eh
